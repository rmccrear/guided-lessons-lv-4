import { Lesson } from '../types';

export const PERSISTENCE_WITH_SUPABASE_LESSONS: Lesson[] = [
  {
    id: "persistence-with-supabase-understanding-manage-data-from-memory-to-database-change",
    title: "Understanding: Manage Data â€” From Memory to Database CHANGE",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "reading",
    content: `
**User Story:** As a developer, I want to store my application data in a real database so that it survives server restarts and scales with my users.

We are moving from **In-Memory Arrays** to **Supabase** (PostgreSQL).

### Why the Switch?

- **Persistence:** In-memory data vanishes when the server stops. Database data lives forever.
- **Power:** You get powerful filtering, sorting, and relations out of the box.
- **Scalability:** Arrays get slow with thousands of items; databases handle millions.

### The Architecture

Instead of a variable in your file, your Express server will act as a **Client** that talks to the Supabase **Server**.
`
  },
  {
    id: "persistence-with-supabase-setup-supabase-in-node",
    title: "Setup Supabase in Node",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a developer, I need to install the necessary libraries and configure my environment variables so that my server can authenticate with the database.

### Instructions

1. **Install Dependencies:**
   Run \`npm install @supabase/supabase-js dotenv\` in your terminal.

2. **Create \`.env\` file:**
   Create a file named \`.env\` in your root directory. Add your project URL and Key (found in your Supabase Dashboard settings).



3. **Configure the Client:**
   Create a new file \`src/supabase.js\` to initialize and export the connection.


`
    ,codeSnippets: [
      {
        language: "env",
        summary: "Show Me: Environment Variables",
        code: `
SUPABASE_URL=https://your-project-url.supabase.co
SUPABASE_KEY=your-anon-public-key
`,
        description: "Snippet for: Show Me: Environment Variables"
      },
      {
        language: "javascript",
        summary: "Show Me: Supabase Configuration",
        code: `
// src/supabase.js
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;
`,
        description: "Snippet for: Show Me: Supabase Configuration"
      }
    ]
  },
  {
    id: "persistence-with-supabase-design-your-table",
    title: "Design Your Table",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As an architect, I want to define the schema of my database table so that Supabase knows how to store my data.

### Instructions

1. **Go to Supabase Dashboard:** Open the Table Editor.
2. **Create a New Table:** Name it according to your resource (e.g., \`books\`, \`courses\`).
3. **Add Columns:** Match the fields you need.
   - \`id\` (int8, Primary Key, Auto-increment) - **Let Supabase handle this!**
   - \`title\` (text)
   - \`author\` (text)
   - \`price\` (float4)

### ðŸ’¡ Code Hints

Even though the DB handles the schema, keep a reference object in your code for testing:


`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: Reference Object",
        code: `
// For reference only - this is now a Table in Supabase!
const bookShape = {
  // id: generated by DB
  title: 'The Great Gatsby', // text
  author: 'F. Scott Fitzgerald', // text
  price: 10.99 // float
};
`,
        description: "Snippet for: Show Me: Reference Object"
      }
    ]
  },
  {
    id: "persistence-with-supabase-connect-client-to-server",
    title: "Connect Client to Server",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a developer, I want to import my Supabase client into my server file so I can start making queries.

### Instructions

1. Open \`src/index.js\`.
2. Import the \`supabase\` client you created in the setup step.
3. Ensure \`express.json()\` middleware is used (crucial for passing data to Supabase).


`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: Import Logic",
        code: `
import express from 'express';
import supabase from './supabase.js'; // Import the connection

const app = express();
app.use(express.json());
`,
        description: "Snippet for: Show Me: Import Logic"
      }
    ]
  },
  {
    id: "persistence-with-supabase-build-get-resource",
    title: "Build GET Resource",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a client, I want to request a list of all resources from the database so that I can display them.

### Instructions

1. Add a \`GET\` route.
2. Use \`await supabase.from('your_table').select('*')\`.
3. Return \`data\` with status \`200\`.


`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: GET with Supabase",
        code: `
app.get('/books', async (req, res) => {
  const { data } = await supabase
    .from('books')
    .select('*');

  res.json(data);
});
`,
        description: "Snippet for: Show Me: GET with Supabase"
      }
    ]
  },
  {
    id: "persistence-with-supabase-build-post-resource",
    title: "Build POST Resource",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a client, I want to insert new rows into the database so that the data is permanently stored.

### Instructions

1. Create a \`POST\` route.
2. Use \`await supabase.from('your_table').insert(req.body).select()\`.
3. **Crucial:** Add \`.select()\` at the end of the chain to return the newly created item (including its generated ID).
4. Return the first item of the \`data\` array with status \`201\`.


`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: POST with Supabase",
        code: `
app.post('/books', async (req, res) => {
  const { title, author, price } = req.body;
  
  const newBook = {
    title,
    author,
    price
  };
  
  const { data } = await supabase
    .from('books')
    .insert(newBook)
    .select()
    .single();

  // Supabase returns an array, we want the single object
  res.status(201).json(data);
});
`,
        description: "Snippet for: Show Me: POST with Supabase"
      }
    ]
  },
  {
    id: "persistence-with-supabase-handling-auto-generated-ids",
    title: "Handling Auto-Generated IDs",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a developer, I want to rely on the database to generate unique IDs so that I don't have to manage complex ID logic in my code.

### Concept Change

In the in-memory lesson, we manually generated IDs using \`randomUUID()\`.
**With Supabase, we stop doing this.**

Postgres (the DB behind Supabase) automatically assigns a unique \`id\` when you \`.insert()\`. Your job is simply to read it back using \`.select()\`.
`
  },
  {
    id: "persistence-with-supabase-implement-get-by-id",
    title: "Implement GET by ID",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a client, I want to query the database for a specific row so that I can view its details.

### Instructions

1. Define a route \`/resource/:id\`.
2. Use \`.select('*').eq('id', req.params.id).single()\`.
3. Return the data with status \`200\`.


`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: GET Single Row",
        code: `
app.get('/books/:id', async (req, res) => {
  const id = req.params.id;
  
  const { data } = await supabase
    .from('books')
    .select('*')
    .eq('id', id)
    .single(); // Efficiently fetches just one

  res.json(data);
});
`,
        description: "Snippet for: Show Me: GET Single Row"
      }
    ]
  },
  {
    id: "persistence-with-supabase-implement-delete-by-id",
    title: "Implement DELETE by ID",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a client, I want to remove a row from the database so that outdated information is permanently deleted.

### Instructions

1. Define a \`DELETE\` route.
2. Use \`await supabase.from('your_table').delete().eq('id', req.params.id)\`.
3. Return a success message with status \`200\`.


`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: DELETE Row",
        code: `
app.delete('/books/:id', async (req, res) => {
  const id = req.params.id;
  
  await supabase
    .from('books')
    .delete()
    .eq('id', id);

  res.status(200).json({ message: 'Book deleted successfully' });
});
`,
        description: "Snippet for: Show Me: DELETE Row"
      }
    ]
  },
  {
    id: "persistence-with-supabase-implement-put-by-id",
    title: "Implement PUT by ID",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a user, I want to update existing book information so that I can correct mistakes or reflect changes.

### Overview

The **PUT** method allows you to update an existing resource. With Supabase, you'll:
1. Use \`.update()\` to modify a row
2. Filter by ID with \`.eq('id', id)\`
3. Return the updated record

### Instructions

1. Create a \`PUT /books/:id\` route
2. Extract the \`id\` from \`req.params\`
3. Get the updated data from \`req.body\`
4. Use Supabase's \`.update()\` method with \`.eq()\` to target the specific book
5. Return the updated book data



### ðŸ’¡ Test It

1. **In Postman**, create a PUT request to \`http://localhost:3000/books/1\`
2. Set the body to JSON:
   \`\`\`json
   {
     "title": "Updated Title",
     "author": "Updated Author",
     "price": 15.99
   }
   \`\`\`
3. Send the request and verify the response shows the updated book
4. Confirm the change persisted by doing a GET request
`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: PUT Route",
        code: `
app.put('/books/:id', async (req, res) => {
  const id = req.params.id;
  const { title, author, price } = req.body;
  
  const updatedBook = {
    title,
    author,
    price
  };
  
  const { data } = await supabase
    .from('books')
    .update(updatedBook)
    .eq('id', id)
    .select();

  res.json(data[0]);
});
`,
        description: "Snippet for: Show Me: PUT Route"
      }
    ]
  },
  {
    id: "persistence-with-supabase-add-error-handling",
    title: "Add Error Handling",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "exercise",
    content: `
**User Story:** As a developer, I want to handle database errors gracefully so that my API provides helpful feedback when things go wrong.

### Concept

Every Supabase operation returns an object with two properties:
- \`data\`: The result if successful
- \`error\`: An error object if something went wrong

Currently, your routes assume everything works perfectly (the "happy path"). In production, you need to check for errors and respond appropriately.

### Instructions

1. For each route, destructure both \`data\` and \`error\` from the Supabase response.
2. Check if \`error\` exists. If it does, return an appropriate error status:
   - \`500\` for database/server errors
   - \`404\` when a resource isn't found (GET by ID)
   - \`400\` for validation errors
3. Only proceed with the success response if no error occurred.



### ðŸ’¡ Your Task

Apply the same error handling pattern to all your other routes:
- POST \`/books\`
- GET \`/books/:id\` (use 404 for not found)
- PUT \`/books/:id\` (use 404 for not found)
- DELETE \`/books/:id\`

### Bonus: Add Validation

Before inserting data, check if required fields exist:

\`\`\`javascript
if (!req.body.title || !req.body.author) {
  return res.status(400).json({ error: 'Title and Author are required' });
}
\`\`\`
`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: GET with Error Handling",
        code: `
app.get('/books', async (req, res) => {
  const { data, error } = await supabase
    .from('books')
    .select('*');

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json(data);
});
`,
        description: "Snippet for: Show Me: GET with Error Handling"
      }
    ]
  },
  {
    id: "persistence-with-supabase-challenge-enable-cors-and-build-a-react-consumer-",
    title: "Challenge: Enable CORS and Build a React Consumer âš¡",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "challenge",
    content: `
**User Story:** As a frontend developer, I want to fetch data from my Express API in a React application so that I can display it in a modern web interface.

### The Problem

By default, browsers block requests from one origin (e.g., \`http://localhost:5173\`) to another (e.g., \`http://localhost:3000\`) for security reasons. This is called **CORS** (Cross-Origin Resource Sharing).

### Part 1: Enable CORS in Express

**Instructions:**

1. Install the CORS middleware: \`npm install cors\`
2. Import and configure CORS in your Express server
3. Test your API endpoints with Postman or your browser



### Part 2: Create a Simple React App

**Instructions:**

1. **Create a new React app** in a separate directory:
   \`\`\`bash
   npm create vite@latest books-client -- --template react
   cd books-client
   npm install
   \`\`\`

2. **Create a component** to fetch and display books:
   - Use \`fetch()\` or \`axios\` to GET data from your API
   - Display the list of books
   - Add a simple form to POST new books

3. **Connect to your API:**
   - Make sure your Express server is running on \`http://localhost:3000\`
   - Make sure your React app is running on \`http://localhost:5173\`
   - Test fetching data from \`/books\`





### ðŸ’¡ Stretch Goals

- Add a form to create new books (POST request)
- Add delete buttons for each book (DELETE request)
- Add error handling and user feedback
- Style your app with Tailwind CSS or another styling solution
- Deploy both the Express API and React app
`
    ,codeSnippets: [
      {
        language: "javascript",
        summary: "Show Me: CORS Configuration",
        code: `
import cors from 'cors';

// Allow requests from your React app
app.use(cors());

// For development, you can also use:
// app.use(cors()); // Allows all origins (not recommended for production!)
`,
        description: "Snippet for: Show Me: CORS Configuration"
      },
      {
        language: "javascript",
        summary: "Show Me: React Component Example Starter Code (GET one by ID)",
        code: `
import { useState, useEffect } from 'react';

function BookDetails({ id }) {

  useEffect(() => {
    fetch(\`http://localhost:3000/books/\${id}\`)
      .then((res) => res.json())
      .then((data) => {
        // data handling
      })
      .catch((err) => {
        // error handling
      });
  }, [id]);

  return (
    <div>
      Hello world
    </div>
  );
}

// usage: <BookDetails id={2} />

export default BookDetails;
`,
        description: "Snippet for: Show Me: React Component Example Starter Code (GET one by ID)"
      },
      {
        language: "javascript",
        summary: "Show Me: React Component Example Full (GET one by ID)",
        code: `
import { useState, useEffect } from 'react';

function BookDetails({ id }) {
  const [book, setBook] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(\`http://localhost:3000/books/\${id}\`)
      .then((res) => res.json())
      .then((data) => {
        setBook(data);
        setLoading(false);
      })
      .catch((err) => {
        console.error('Error fetching book:', err);
        setLoading(false);
      });
  }, [id]);

  if (loading) return <div>Loading...</div>;
  if (!book) return <div>No book found.</div>;

  return (
    <div>
      <h1>{book.title}</h1>
      <p>
        <strong>Author:</strong> {book.author}
      </p>
      <p>
        <strong>Price:</strong> \${book.price}
      </p>
      <p>
        <strong>ID:</strong> {book.id}
      </p>
    </div>
  );
}

// usage: <BookDetails id={2} />

export default BookDetails;
`,
        description: "Snippet for: Show Me: React Component Example Full (GET one by ID)"
      }
    ]
  },
  {
    id: "persistence-with-supabase-understanding-frontend-vs-backend-architecture",
    title: "Understanding: Frontend vs Backend Architecture",
    description: "Transition from in-memory storage to a persistent Postgres database using Supabase.",
    type: "reading",
    content: `
**User Story:** As a full-stack developer, I want to understand how the frontend and backend work together so that I can build complete, scalable applications.

### The Big Picture

You've now built both pieces of a full-stack application:
- **Backend (Express API)**: Manages data, enforces business logic, and talks to the database
- **Frontend (React App)**: Displays data to users, handles interactions, and makes API requests

These two systems are **separate** but **connected** through HTTP requests.

### Key Differences

| Aspect | Backend (Express) | Frontend (React) |
|--------|------------------|------------------|
| **Runs On** | Server (Node.js) | Browser (JavaScript) |
| **Purpose** | Data management, security, business logic | User interface, user experience |
| **Security** | Trusted environment, can store secrets | Untrusted, never store secrets here |
| **Data Access** | Direct database access | Only via API requests |
| **Language** | JavaScript (Node.js) | JavaScript (Browser) |
| **Port** | Usually 3000, 8080, etc. | Usually 5173 (Vite), 3000 (CRA) |

### How They Work Together

![alt:Show Me: Full-Stack Architecture Diagram showing React frontend on port 5173 making HTTP requests (GET, POST, PUT, DELETE) to Express API on port 3000, which connects to Supabase/Postgres database. Arrows show request flow from browser through CORS-enabled API to database and back.](https://placeholder-diagram-url.com/fullstack-architecture.png)

**The Request Flow:**

1. **User Action**: User clicks "Add Book" button in React app
2. **Frontend Request**: React sends \`POST http://localhost:3000/books\` with JSON data
3. **CORS Check**: Express validates the request origin
4. **Backend Processing**: Express validates data, generates ID, calls Supabase
5. **Database Operation**: Supabase inserts the row into Postgres
6. **Response Journey**: Data flows back: Supabase â†’ Express â†’ React
7. **UI Update**: React displays the new book to the user

### Why Separate Them?

**Scalability**: You can deploy the frontend and backend independently. Update the UI without touching the database logic.

**Security**: The backend protects sensitive operations. Users can't directly manipulate your database.

**Flexibility**: Multiple frontends (web, mobile, desktop) can use the same backend API.

**Development**: Teams can work on frontend and backend simultaneously without conflicts.

### The Connection Point: APIs

Your Express routes (\`/books\`, \`/books/:id\`) are the **contract** between frontend and backend:
- Frontend knows: "To get books, I send GET to \`/books\`"
- Backend knows: "When I receive GET \`/books\`, I return JSON array"

This contract allows both sides to evolve independently, as long as the API structure stays consistent.

### ðŸŽ“ You've Built a Full Stack!

Congratulations! You now understand:
- âœ… How to build RESTful APIs with Express
- âœ… How to persist data with Supabase/Postgres
- âœ… How to consume APIs from a React frontend
- âœ… How to enable cross-origin requests with CORS
- âœ… The architectural relationship between frontend and backend

This foundation scales to production applications used by millions of users. The same patterns apply whether you're building a simple CRUD app or a complex enterprise system.
`
  }
];
