---
id: persistence-with-supabase
title: Persistence with Supabase
type: exercise
description: Transition from in-memory storage to a persistent Postgres database using Supabase.
---

# Persistence with Supabase

## Manage Data â€” From Memory to Database

**User Story:** As a developer, I want to store my application data in a real database so that it survives server restarts and scales with my users.

We are moving from **In-Memory Arrays** to **Supabase** (PostgreSQL).

### Why the Switch?

- **Persistence:** In-memory data vanishes when the server stops. Database data lives forever.
- **Power:** You get powerful filtering, sorting, and relations out of the box.
- **Scalability:** Arrays get slow with thousands of items; databases handle millions.

### The Architecture

Instead of a variable in your file, your Express server will act as a **Client** that talks to the Supabase **Server**.

## Setup Supabase in Node

**User Story:** As a developer, I need to install the necessary libraries and configure my environment variables so that my server can authenticate with the database.

### Instructions

1. **Install Dependencies:**
   Run `npm install @supabase/supabase-js dotenv` in your terminal.

2. **Create `.env` file:**
   Create a file named `.env` in your root directory. Add your project URL and Key (found in your Supabase Dashboard settings).

```env:Show Me: Environment Variables
SUPABASE_URL=https://your-project-url.supabase.co
SUPABASE_KEY=your-anon-public-key
```

3. **Configure the Client:**
   Create a new file `src/supabase.js` to initialize and export the connection.

```javascript:Show Me: Supabase Configuration
// src/supabase.js
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;
```

## Design Your Table

**User Story:** As an architect, I want to define the schema of my database table so that Supabase knows how to store my data.

### Instructions

1. **Go to Supabase Dashboard:** Open the Table Editor.
2. **Create a New Table:** Name it according to your resource (e.g., `books`, `courses`).
3. **Add Columns:** Match the fields you need.
   - `id` (int8, Primary Key, Auto-increment) - **Let Supabase handle this!**
   - `title` (text)
   - `author` (text)
   - `price` (float4)

### ðŸ’¡ Code Hints

Even though the DB handles the schema, keep a reference object in your code for testing:

```javascript:Show Me: Reference Object
// For reference only - this is now a Table in Supabase!
const bookShape = {
  // id: generated by DB
  title: 'The Great Gatsby', // text
  author: 'F. Scott Fitzgerald', // text
  price: 10.99 // float
};
```

## Connect Client to Server

**User Story:** As a developer, I want to import my Supabase client into my server file so I can start making queries.

### Instructions

1. Open `src/index.js`.
2. Import the `supabase` client you created in the setup step.
3. Ensure `express.json()` middleware is used (crucial for passing data to Supabase).

```javascript:Show Me: Import Logic
import express from 'express';
import supabase from './supabase.js'; // Import the connection

const app = express();
app.use(express.json());
```

## Build GET Resource

**User Story:** As a client, I want to request a list of all resources from the database so that I can display them.

### Instructions

1. Add a `GET` route.
2. Use `await supabase.from('your_table').select('*')`.
3. Handle errors: If the database fails, return a `500`.
4. Return `data` with status `200`.

```javascript:Show Me: GET with Supabase
app.get('/books', async (req, res) => {
  const { data, error } = await supabase
    .from('books')
    .select('*');

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json(data);
});
```

## Build POST Resource

**User Story:** As a client, I want to insert new rows into the database so that the data is permanently stored.

### Instructions

1. Create a `POST` route.
2. Use `await supabase.from('your_table').insert(req.body).select()`.
3. **Crucial:** Add `.select()` at the end of the chain to return the newly created item (including its generated ID).
4. Return the first item of the `data` array with status `201`.

```javascript:Show Me: POST with Supabase
app.post('/books', async (req, res) => {
  const { data, error } = await supabase
    .from('books')
    .insert(req.body)
    .select(); // Returns the created record

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  // Supabase returns an array, we want the single object
  res.status(201).json(data[0]);
});
```

## Enforce Basic Validation

**User Story:** As a developer, I want to validate data *before* sending it to the database to save bandwidth and ensure data integrity.

### Instructions

1. Check if required fields are present in `req.body`.
2. If data is missing, short-circuit the function and return `400` *before* calling Supabase.

```javascript:Show Me: Validation Check
app.post('/books', async (req, res) => {
  // Validate BEFORE talking to the database
  if (!req.body.title || !req.body.author) {
    return res.status(400).json({ error: 'Title and Author are required' });
  }

  // ... proceed to supabase insert ...
});
```

## Handling Auto-Generated IDs

**User Story:** As a developer, I want to rely on the database to generate unique IDs so that I don't have to manage complex ID logic in my code.

### Concept Change

In the in-memory lesson, we manually generated IDs using `randomUUID()`.
**With Supabase, we stop doing this.**

Postgres (the DB behind Supabase) automatically assigns a unique `id` when you `.insert()`. Your job is simply to read it back using `.select()`.

## Implement GET by ID

**User Story:** As a client, I want to query the database for a specific row so that I can view its details.

### Instructions

1. Define a route `/resource/:id`.
2. Use `.select('*').eq('id', req.params.id)`.
3. Use `.single()` to tell Supabase we expect exactly one result.
4. Handle the error (Supabase returns a specific error code for "Row not found").

```javascript:Show Me: GET Single Row
app.get('/books/:id', async (req, res) => {
  const { data, error } = await supabase
    .from('books')
    .select('*')
    .eq('id', req.params.id)
    .single(); // Efficiently fetches just one

  if (error) {
    return res.status(404).json({ error: 'Book not found' });
  }

  res.json(data);
});
```

## Implement DELETE by ID

**User Story:** As a client, I want to remove a row from the database so that outdated information is permanently deleted.

### Instructions

1. Define a `DELETE` route.
2. Use `await supabase.from('your_table').delete().eq('id', req.params.id)`.
3. Check for errors.

```javascript:Show Me: DELETE Row
app.delete('/books/:id', async (req, res) => {
  const { error } = await supabase
    .from('books')
    .delete()
    .eq('id', req.params.id);

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.status(200).json({ message: 'Book deleted successfully' });
});
```