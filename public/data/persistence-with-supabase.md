---
id: persistence-with-supabase
title: Persistence with Supabase
type: exercise
description: Transition from in-memory storage to a persistent Postgres database using Supabase.
---

# Persistence with Supabase

## Manage Data â€” From Memory to Database

**User Story:** As a developer, I want to store my application data in a real database so that it survives server restarts and scales with my users.

We are moving from **In-Memory Arrays** to **Supabase** (PostgreSQL).

### Why the Switch?

- **Persistence:** In-memory data vanishes when the server stops. Database data lives forever.
- **Power:** You get powerful filtering, sorting, and relations out of the box.
- **Scalability:** Arrays get slow with thousands of items; databases handle millions.

### The Architecture

Instead of a variable in your file, your Express server will act as a **Client** that talks to the Supabase **Server**.

## Setup Supabase in Node

**User Story:** As a developer, I need to install the necessary libraries and configure my environment variables so that my server can authenticate with the database.

### Instructions

1. **Install Dependencies:**
   Run `npm install @supabase/supabase-js dotenv` in your terminal.

2. **Create `.env` file:**
   Create a file named `.env` in your root directory. Add your project URL and Key (found in your Supabase Dashboard settings).

```env:Show Me: Environment Variables
SUPABASE_URL=https://your-project-url.supabase.co
SUPABASE_KEY=your-anon-public-key
```

3. **Configure the Client:**
   Create a new file `src/supabase.js` to initialize and export the connection.

```javascript:Show Me: Supabase Configuration
// src/supabase.js
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;

const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;
```

## Design Your Table

**User Story:** As an architect, I want to define the schema of my database table so that Supabase knows how to store my data.

### Instructions

1. **Go to Supabase Dashboard:** Open the Table Editor.
2. **Create a New Table:** Name it according to your resource (e.g., `books`, `courses`).
3. **Add Columns:** Match the fields you need.
   - `id` (int8, Primary Key, Auto-increment) - **Let Supabase handle this!**
   - `title` (text)
   - `author` (text)
   - `price` (float4)

### ðŸ’¡ Code Hints

Even though the DB handles the schema, keep a reference object in your code for testing:

```javascript:Show Me: Reference Object
// For reference only - this is now a Table in Supabase!
const bookShape = {
  // id: generated by DB
  title: 'The Great Gatsby', // text
  author: 'F. Scott Fitzgerald', // text
  price: 10.99 // float
};
```

## Connect Client to Server

**User Story:** As a developer, I want to import my Supabase client into my server file so I can start making queries.

### Instructions

1. Open `src/index.js`.
2. Import the `supabase` client you created in the setup step.
3. Ensure `express.json()` middleware is used (crucial for passing data to Supabase).

```javascript:Show Me: Import Logic
import express from 'express';
import supabase from './supabase.js'; // Import the connection

const app = express();
app.use(express.json());
```

## Build GET Resource

**User Story:** As a client, I want to request a list of all resources from the database so that I can display them.

### Instructions

1. Add a `GET` route.
2. Use `await supabase.from('your_table').select('*')`.
3. Return `data` with status `200`.

```javascript:Show Me: GET with Supabase
app.get('/books', async (req, res) => {
  const { data } = await supabase
    .from('books')
    .select('*');

  res.json(data);
});
```

## Build POST Resource

**User Story:** As a client, I want to insert new rows into the database so that the data is permanently stored.

### Instructions

1. Create a `POST` route.
2. Use `await supabase.from('your_table').insert(req.body).select()`.
3. **Crucial:** Add `.select()` at the end of the chain to return the newly created item (including its generated ID).
4. Return the first item of the `data` array with status `201`.

```javascript:Show Me: POST with Supabase
app.post('/books', async (req, res) => {
  const { data } = await supabase
    .from('books')
    .insert(req.body)
    .select(); // Returns the created record

  // Supabase returns an array, we want the single object
  res.status(201).json(data[0]);
});
```

## Handling Auto-Generated IDs

**User Story:** As a developer, I want to rely on the database to generate unique IDs so that I don't have to manage complex ID logic in my code.

### Concept Change

In the in-memory lesson, we manually generated IDs using `randomUUID()`.
**With Supabase, we stop doing this.**

Postgres (the DB behind Supabase) automatically assigns a unique `id` when you `.insert()`. Your job is simply to read it back using `.select()`.

## Implement GET by ID

**User Story:** As a client, I want to query the database for a specific row so that I can view its details.

### Instructions

1. Define a route `/resource/:id`.
2. Use `.select('*').eq('id', req.params.id).single()`.
3. Return the data with status `200`.

```javascript:Show Me: GET Single Row
app.get('/books/:id', async (req, res) => {
  const id = req.params.id;
  
  const { data } = await supabase
    .from('books')
    .select('*')
    .eq('id', id)
    .single(); // Efficiently fetches just one

  res.json(data);
});
```

## Implement DELETE by ID

**User Story:** As a client, I want to remove a row from the database so that outdated information is permanently deleted.

### Instructions

1. Define a `DELETE` route.
2. Use `await supabase.from('your_table').delete().eq('id', req.params.id)`.
3. Return a success message with status `200`.

```javascript:Show Me: DELETE Row
app.delete('/books/:id', async (req, res) => {
  const id = req.params.id;
  
  await supabase
    .from('books')
    .delete()
    .eq('id', id);

  res.status(200).json({ message: 'Book deleted successfully' });
});
```

## Add Error Handling

**User Story:** As a developer, I want to handle database errors gracefully so that my API provides helpful feedback when things go wrong.

### Concept

Every Supabase operation returns an object with two properties:
- `data`: The result if successful
- `error`: An error object if something went wrong

Currently, your routes assume everything works perfectly (the "happy path"). In production, you need to check for errors and respond appropriately.

### Instructions

1. For each route, destructure both `data` and `error` from the Supabase response.
2. Check if `error` exists. If it does, return an appropriate error status:
   - `500` for database/server errors
   - `404` when a resource isn't found (GET by ID)
   - `400` for validation errors
3. Only proceed with the success response if no error occurred.

```javascript:Show Me: GET with Error Handling
app.get('/books', async (req, res) => {
  const { data, error } = await supabase
    .from('books')
    .select('*');

  if (error) {
    return res.status(500).json({ error: error.message });
  }

  res.json(data);
});
```

### ðŸ’¡ Your Task

Apply the same error handling pattern to all your other routes:
- POST `/books`
- GET `/books/:id` (use 404 for not found)
- DELETE `/books/:id`

### Bonus: Add Validation

Before inserting data, check if required fields exist:

```javascript
if (!req.body.title || !req.body.author) {
  return res.status(400).json({ error: 'Title and Author are required' });
}
```

## Challenge: Enable CORS and Build a React Consumer âš¡

**User Story:** As a frontend developer, I want to fetch data from my Express API in a React application so that I can display it in a modern web interface.

### The Problem

By default, browsers block requests from one origin (e.g., `http://localhost:5173`) to another (e.g., `http://localhost:3000`) for security reasons. This is called **CORS** (Cross-Origin Resource Sharing).

### Part 1: Enable CORS in Express

**Instructions:**

1. Install the CORS middleware: `npm install cors`
2. Import and configure CORS in your Express server
3. Test your API endpoints with Postman or your browser

```javascript:Show Me: CORS Configuration
import cors from 'cors';

// Allow requests from your React app
app.use(cors({
  origin: 'http://localhost:5173', // Your React dev server
  methods: ['GET', 'POST', 'DELETE'],
  credentials: true
}));

// For development, you can also use:
// app.use(cors()); // Allows all origins (not recommended for production!)
```

### Part 2: Create a Simple React App

**Instructions:**

1. **Create a new React app** in a separate directory:
   ```bash
   npm create vite@latest books-client -- --template react
   cd books-client
   npm install
   ```

2. **Create a component** to fetch and display books:
   - Use `fetch()` or `axios` to GET data from your API
   - Display the list of books
   - Add a simple form to POST new books

3. **Connect to your API:**
   - Make sure your Express server is running on `http://localhost:3000`
   - Make sure your React app is running on `http://localhost:5173`
   - Test fetching data from `/books`

```javascript:Show Me: React Component Example Starter Code (GET one by ID)
import { useState, useEffect } from 'react';

function BookDetails({ id }) {

  useEffect(() => {
    fetch(`http://localhost:3000/books/${id}`)
      .then((res) => res.json())
      .then((data) => {
        // data handling
      })
      .catch((err) => {
        // error handling
      });
  }, [id]);

  return (
    <div>
      Hello world
    </div>
  );
}

// usage: <BookDetails id={2} />

export default BookDetails;
```

```javascript:Show Me: React Component Example Full (GET one by ID)
import { useState, useEffect } from 'react';

function BookDetails({ id }) {
  const [book, setBook] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(`http://localhost:3000/books/${id}`)
      .then((res) => res.json())
      .then((data) => {
        setBook(data);
        setLoading(false);
      })
      .catch((err) => {
        console.error('Error fetching book:', err);
        setLoading(false);
      });
  }, [id]);

  if (loading) return <div>Loading...</div>;
  if (!book) return <div>No book found.</div>;

  return (
    <div>
      <h1>{book.title}</h1>
      <p>
        <strong>Author:</strong> {book.author}
      </p>
      <p>
        <strong>Price:</strong> ${book.price}
      </p>
      <p>
        <strong>ID:</strong> {book.id}
      </p>
    </div>
  );
}

// usage: <BookDetails id={2} />

export default BookDetails;
```

### ðŸ’¡ Stretch Goals

- Add a form to create new books (POST request)
- Add delete buttons for each book (DELETE request)
- Add error handling and user feedback
- Style your app with Tailwind CSS or another styling solution
- Deploy both the Express API and React app